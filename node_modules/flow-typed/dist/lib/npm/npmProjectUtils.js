"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findPackageJsonDepVersionStr = findPackageJsonDepVersionStr;
exports.findPackageJsonPath = findPackageJsonPath;
exports.getPackageJsonDependencies = getPackageJsonDependencies;
exports.getPackageJsonData = getPackageJsonData;
exports.determineFlowVersion = determineFlowVersion;
exports.findFlowSpecificVer = findFlowSpecificVer;

var _fileUtils = require("../fileUtils.js");

var _node = require("../node.js");

var _semver = require("../semver.js");

var _semver2 = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PKG_JSON_DEP_FIELDS = ['dependencies', 'devDependencies', 'peerDependencies', 'bundledDependencies'];

async function findPackageJsonDepVersionStr(pkgJson, depName) {
  let matchedFields = [];
  const deps = PKG_JSON_DEP_FIELDS.reduce((deps, section) => {
    const contentSection = pkgJson.content[section];

    if (contentSection && contentSection[depName]) {
      matchedFields.push(section);
      deps.push(contentSection[depName]);
    }

    return deps;
  }, []);

  if (deps.length === 0) {
    return null;
  } else if (deps.length === 1) {
    return deps.pop();
  } else {
    throw new Error(`Found ${depName} listed in ${String(deps.length)} places in ` + `${pkgJson.pathStr}!`);
  }
}

async function findPackageJsonPath(pathStr) {
  const pkgJsonPathStr = await (0, _fileUtils.searchUpDirPath)(pathStr, async p => await _node.fs.exists(_node.path.join(p, 'package.json')));

  if (pkgJsonPathStr === null) {
    throw new Error(`Unable to find a package.json for ${pathStr}!`);
  }

  return _node.path.join(pkgJsonPathStr, 'package.json');
} // TODO: Write tests for this


function getPackageJsonDependencies(pkgJson, ignoreDeps) {
  const depFields = PKG_JSON_DEP_FIELDS.filter(field => {
    return ignoreDeps.indexOf(field.slice(0, -12)) === -1;
  });
  return depFields.reduce((deps, section) => {
    const contentSection = pkgJson.content[section];

    if (contentSection) {
      Object.keys(contentSection).forEach(pkgName => {
        if (deps[pkgName]) {
          console.warn(`Found ${pkgName} listed twice in package.json!`);
        }

        deps[pkgName] = contentSection[pkgName];
      });
    }

    return deps;
  }, {});
}

async function getPackageJsonData(pathStr) {
  const pkgJsonPath = await findPackageJsonPath(pathStr);
  const pkgJsonContent = await _node.fs.readFile(pkgJsonPath);
  return {
    pathStr: pkgJsonPath,
    content: JSON.parse(pkgJsonContent.toString())
  };
}

async function determineFlowVersion(pathStr) {
  const pkgJsonData = await getPackageJsonData(pathStr);
  const flowBinVersionStr = await findPackageJsonDepVersionStr(pkgJsonData, 'flow-bin');

  if (flowBinVersionStr !== null) {
    let flowVerStr;

    if (_semver2.default.valid(flowBinVersionStr)) {
      flowVerStr = flowBinVersionStr;
    } else {
      const flowVerRange = new _semver2.default.Range(flowBinVersionStr);

      if (flowVerRange.set[0].length !== 2) {
        const cliPkgJson = require('../../../package.json');

        const cliFlowVer = cliPkgJson.devDependencies['flow-bin'];
        throw new Error(`Unable to extract flow-bin version from package.json!\n` + `Never use a complex version range with flow-bin. Always use a ` + `specific version (i.e. "${cliFlowVer}").`);
      }

      flowVerStr = flowVerRange.set[0][0].semver.version;
    }

    return (0, _semver.stringToVersion)('v' + flowVerStr);
  }

  return null;
}

async function findFlowSpecificVer(startingPath) {
  const flowSemver = await determineFlowVersion(startingPath);

  if (flowSemver === null) {
    throw new Error('Failed to find a flow-bin dependency in package.json.\n' + 'Please install flow-bin: `npm install --save-dev flow-bin`');
  }

  if (flowSemver.range !== undefined) {
    throw new Error(`Unable to extract flow-bin version from package.json!\n` + `Never use a complex version range with flow-bin. Always use a ` + `specific major/minor version (i.e. "^0.39").`);
  }

  const major = flowSemver.major;

  if (major === 'x') {
    throw new Error(`Unable to extract flow-bin version from package.json!\n` + `Never use a wildcard major version with flow-bin!`);
  }

  return {
    major,
    minor: flowSemver.minor,
    patch: flowSemver.patch,
    prerel: flowSemver.prerel == null ? null : flowSemver.prerel
  };
}