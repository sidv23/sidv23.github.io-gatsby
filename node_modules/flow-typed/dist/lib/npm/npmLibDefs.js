"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findNpmLibDef = findNpmLibDef;
exports.parseSignedCodeVersion = parseSignedCodeVersion;
exports.getInstalledNpmLibDef = getInstalledNpmLibDef;
exports.getInstalledNpmLibDefs = getInstalledNpmLibDefs;
exports.getNpmLibDefs = getNpmLibDefs;
exports.getNpmLibDefVersionHash = getNpmLibDefVersionHash;
exports.getScopedPackageName = getScopedPackageName;
exports._extractLibDefsFromNpmPkgDir = extractLibDefsFromNpmPkgDir;
exports._parsePkgNameVer = parsePkgNameVer;
exports._validateVersionNumPart = validateVersionNumPart;
exports._validateVersionPart = validateVersionPart;

var _cacheRepoUtils = require("../cacheRepoUtils");

var _codeSign = require("../codeSign");

var _fileUtils = require("../fileUtils");

var _flowVersion = require("../flowVersion");

var _git = require("../git");

var _node = require("../node");

var _semver = require("../semver");

var _semver2 = _interopRequireDefault(require("semver"));

var _got = _interopRequireDefault(require("got"));

var _ValidationError = require("../ValidationError");

var _libDefs = require("../libDefs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const P = Promise;

async function extractLibDefsFromNpmPkgDir(pkgDirPath, scope, pkgNameVer, validating) {
  const parsedPkgNameVer = parsePkgNameVer(pkgNameVer);

  if (parsedPkgNameVer === null) {
    return [];
  }

  const {
    pkgName,
    pkgVersion
  } = parsedPkgNameVer;
  const pkgVersionStr = (0, _semver.versionToString)(pkgVersion);
  const libDefFileName = `${pkgName}_${pkgVersionStr}.js`;
  const pkgDirItems = await _node.fs.readdir(pkgDirPath);

  if (validating) {
    const fullPkgName = `${scope === null ? '' : scope + '/'}${pkgName}`;
    await _npmExists(fullPkgName).then().catch(error => {
      if (error.HTTPError && error.HTTPError.response.statusCode === 404) {
        // Some times NPM returns 404 even though the package exists.
        // Try to avoid false negatives by retrying
        return new Promise((resolve, reject) => setTimeout(() => {
          _npmExists(fullPkgName).then(resolve).catch(reject);
        }, 1000));
      }
    }).then().catch(error => {
      // Only fail on 404, not on timeout
      if (error.HTTPError && error.HTTPError.statusCode === 404) {
        throw new _ValidationError.ValidationError(`Package does not exist on npm!`);
      }
    });
  }

  const commonTestFiles = [];
  const parsedFlowDirs = [];
  pkgDirItems.forEach(pkgDirItem => {
    const pkgDirItemPath = _node.path.join(pkgDirPath, pkgDirItem);

    const pkgDirItemStat = _node.fs.statSync(pkgDirItemPath);

    if (pkgDirItemStat.isFile()) {
      const isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(pkgDirItem);

      if (isValidTestFile) commonTestFiles.push(pkgDirItemPath);
    } else if (pkgDirItemStat.isDirectory()) {
      const parsedFlowDir = (0, _flowVersion.parseDirString)(pkgDirItem);
      parsedFlowDirs.push([pkgDirItemPath, parsedFlowDir]);
    } else {
      throw new _ValidationError.ValidationError('Unexpected directory item');
    }
  });

  if (!(0, _flowVersion.disjointVersionsAll)(parsedFlowDirs.map(([_, ver]) => ver))) {
    throw new _ValidationError.ValidationError('Flow versions not disjoint!');
  }

  if (parsedFlowDirs.length === 0) {
    throw new _ValidationError.ValidationError('No libdef files found!');
  }

  const libDefs = [];
  await P.all(parsedFlowDirs.map(async ([flowDirPath, flowVersion]) => {
    const testFilePaths = [].concat(commonTestFiles);
    let libDefFilePath = null;
    (await _node.fs.readdir(flowDirPath)).forEach(flowDirItem => {
      const flowDirItemPath = _node.path.join(flowDirPath, flowDirItem);

      const flowDirItemStat = _node.fs.statSync(flowDirItemPath);

      if (flowDirItemStat.isFile()) {
        if (_node.path.extname(flowDirItem) === '.swp') {
          return;
        } // Is this the libdef file?


        if (flowDirItem === libDefFileName) {
          libDefFilePath = _node.path.join(flowDirPath, flowDirItem);
          return;
        } // Is this a test file?


        const isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(flowDirItem);

        if (isValidTestFile) {
          testFilePaths.push(flowDirItemPath);
          return;
        }

        throw new _ValidationError.ValidationError(`Unexpected file: ${libDefFileName}. This directory can only contain test files ` + `or a libdef file named ${'`' + libDefFileName + '`'}.`);
      } else {
        throw new _ValidationError.ValidationError(`Unexpected sub-directory. This directory can only contain test ` + `files or a libdef file named ${'`' + libDefFileName + '`'}.`);
      }
    });

    if (libDefFilePath === null) {
      libDefFilePath = _node.path.join(flowDirPath, libDefFileName);
      throw new _ValidationError.ValidationError(`No libdef file found. Looking for a file named ${libDefFileName}`);
    }

    libDefs.push({
      scope,
      name: pkgName,
      version: pkgVersionStr,
      flowVersion,
      path: libDefFilePath,
      testFilePaths
    });
  }));
  return libDefs;
}

async function getCacheNpmLibDefs(cacheExpiry) {
  await (0, _cacheRepoUtils.ensureCacheRepo)(cacheExpiry);
  await (0, _cacheRepoUtils.verifyCLIVersion)();
  return getNpmLibDefs(_node.path.join((0, _cacheRepoUtils.getCacheRepoDir)(), 'definitions'));
}

const PKG_NAMEVER_RE = /^(.*)_v\^?([0-9]+)\.([0-9]+|x)\.([0-9]+|x)(-.*)?$/;
const PKG_GIT_RE = /^([\w\-]+)@([\w\.]+):([\w\-]+)\/([\w\-]+)(?:\.git)$/;

function parsePkgNameVer(pkgNameVer) {
  const pkgNameVerMatches = pkgNameVer.match(PKG_NAMEVER_RE);
  const pkgNameGitMatches = pkgNameVer.match(PKG_GIT_RE);

  if (pkgNameGitMatches != null) {
    return {
      pkgName: pkgNameGitMatches[4],
      pkgVersion: {
        major: 0,
        minor: 0,
        patch: 0,
        prerel: ''
      }
    };
  }

  if (pkgNameVerMatches == null) {
    throw new _ValidationError.ValidationError(`Malformed npm package name! ` + `Expected the name to be formatted as <PKGNAME>_v<MAJOR>.<MINOR>.<PATCH> but instead got ${pkgNameVer}`);
  }

  let [_, pkgName, major, minor, patch, prerel] = pkgNameVerMatches;
  major = validateVersionNumPart(major, 'major');
  minor = validateVersionPart(minor, 'minor');
  patch = validateVersionPart(patch, 'patch');

  if (prerel != null) {
    prerel = prerel.substr(1);
  }

  return {
    pkgName,
    pkgVersion: {
      major,
      minor,
      patch,
      prerel
    }
  };
}
/**
 * Given a number-or-wildcard part of a version string (i.e. a `minor` or
 * `patch` part), parse the string into either a number or 'x'.
 */


function validateVersionPart(part, partName) {
  if (part === 'x') {
    return part;
  }

  return validateVersionNumPart(part, partName);
}
/**
 * Given a number-only part of a version string (i.e. the `major` part), parse
 * the string into a number.
 */


function validateVersionNumPart(part, partName) {
  const num = parseInt(part, 10);

  if (String(num) !== part) {
    throw new _ValidationError.ValidationError(`Invalid ${partName} number: '${part}'. Expected a number.`);
  }

  return num;
}

function pkgVersionMatch(pkgSemver, libDefSemverRaw) {
  // The package version should be treated as a semver implicitly prefixed by a
  // `^`. (i.e.: "foo_v2.2.x" is the same range as "^2.2.x")
  // UNLESS it is prefixed by the equals character (i.e. "foo_=v2.2.x")
  let libDefSemver = libDefSemverRaw[0] !== '=' && libDefSemverRaw[0] !== '^' ? '^' + libDefSemverRaw : libDefSemverRaw;

  if (_semver2.default.valid(pkgSemver)) {
    // Test the single package version against the LibDef range
    return _semver2.default.satisfies(pkgSemver, libDefSemver);
  }

  if (_semver2.default.valid(libDefSemver)) {
    // Test the single LibDef version against the package range
    return _semver2.default.satisfies(libDefSemver, pkgSemver);
  }

  if (!(_semver2.default.validRange(pkgSemver) && _semver2.default.validRange(libDefSemver))) {
    return false;
  }

  const pkgRange = new _semver2.default.Range(pkgSemver);
  const libDefRange = new _semver2.default.Range(libDefSemver);

  if (libDefRange.set[0].length !== 2) {
    throw new Error('Invalid npm libdef version! It appears to be a non-continugous range.');
  }

  const libDefLower = (0, _semver.getRangeLowerBound)(libDefRange);
  const libDefUpper = (0, _semver.getRangeUpperBound)(libDefRange);

  const pkgBelowLower = _semver2.default.gtr(libDefLower, pkgSemver);

  const pkgAboveUpper = _semver2.default.ltr(libDefUpper, pkgSemver);

  if (pkgBelowLower || pkgAboveUpper) {
    return false;
  }

  const pkgLower = pkgRange.set[0][0].semver.version;
  return libDefRange.test(pkgLower);
}

function filterLibDefs(defs, filter) {
  return defs.filter(def => {
    let filterMatch = false;

    switch (filter.type) {
      case 'exact':
        const fullName = def.scope ? `${def.scope}/${def.name}` : def.name;
        filterMatch = filter.pkgName.toLowerCase() === fullName.toLowerCase() && pkgVersionMatch(filter.pkgVersion, def.version);
        break;

      default:
        filter;
    }

    if (!filterMatch) {
      return false;
    }

    const filterFlowVersion = filter.flowVersion;

    if (filterFlowVersion !== undefined) {
      const {
        flowVersion
      } = def;

      switch (flowVersion.kind) {
        case 'all':
          return true;

        case 'ranged':
        case 'specific':
          return _semver2.default.satisfies((0, _flowVersion.toSemverString)(filterFlowVersion), (0, _flowVersion.toSemverString)(def.flowVersion));

        default:
          flowVersion;
      }
    }

    return true;
  }).sort((a, b) => {
    const aZeroed = a.version.replace(/x/g, '0');
    const bZeroed = b.version.replace(/x/g, '0');
    return _semver2.default.gt(aZeroed, bZeroed) ? -1 : 1;
  });
}

async function _npmExists(pkgName) {
  const pkgUrl = `https://www.npmjs.com/package/${pkgName}`;
  return (0, _got.default)(pkgUrl, {
    method: 'HEAD'
  });
}

async function findNpmLibDef(pkgName, pkgVersion, flowVersion, useCacheUntil = _cacheRepoUtils.CACHE_REPO_EXPIRY) {
  const libDefs = await getCacheNpmLibDefs(useCacheUntil);
  const filteredLibDefs = filterLibDefs(libDefs, {
    type: 'exact',
    pkgName,
    pkgVersion,
    flowVersion
  });
  return filteredLibDefs.length === 0 ? null : filteredLibDefs[0];
}

function parseSignedCodeVersion(signedCodeVer) {
  if (signedCodeVer === null) {
    return null;
  }

  if (signedCodeVer.startsWith('<<STUB>>/')) {
    return {
      kind: 'Stub',
      name: signedCodeVer.substring('<<STUB>>/'.length)
    };
  }

  const matches = signedCodeVer.match(/([^\/]+)\/(@[^\/]+\/)?([^\/]+)\/([^\/]+)/);

  if (matches == null) {
    return null;
  }

  const scope = matches[2] == null ? null : matches[2].substr(0, matches[2].length - 1);
  const nameVer = matches[3];

  if (nameVer === null) {
    return null;
  }

  const pkgNameVer = parsePkgNameVer(nameVer);

  if (pkgNameVer === null) {
    return null;
  }

  const {
    pkgName,
    pkgVersion
  } = pkgNameVer;
  const flowVerMatches = matches[4].match(/^flow_(>=|<=)?(v[^ ]+) ?(<=(v.+))?$/);
  const flowVerStr = flowVerMatches == null ? matches[3] : flowVerMatches[3] == null ? flowVerMatches[2] : `${flowVerMatches[2]}-${flowVerMatches[4]}`;
  const flowDirStr = `flow_${flowVerStr}`;
  const flowVer = flowVerMatches == null ? (0, _flowVersion.parseDirString)(flowDirStr) : (0, _flowVersion.parseDirString)(flowDirStr);
  return {
    kind: 'LibDef',
    libDef: {
      scope,
      name: pkgName,
      version: (0, _semver.versionToString)(pkgVersion),
      flowVersion: flowVer,
      testFilePaths: []
    }
  };
}

async function getInstalledNpmLibDef(flowProjectRootDir, fullFilePath) {
  const terseFilePath = _node.path.relative(flowProjectRootDir, fullFilePath);

  const fileStat = await _node.fs.stat(fullFilePath);

  if (fileStat.isFile()) {
    const fileContent = (await _node.fs.readFile(fullFilePath)).toString();

    if ((0, _codeSign.verifySignedCode)(fileContent)) {
      const signedCodeVer = (0, _codeSign.getSignedCodeVersion)(fileContent);

      if (signedCodeVer === null) {
        return null;
      }

      const parsed = parseSignedCodeVersion(signedCodeVer);

      if (!parsed) {
        return null;
      }

      return [terseFilePath, parsed.kind === 'LibDef' ? {
        kind: 'LibDef',
        libDef: { ...parsed.libDef,
          path: terseFilePath
        }
      } : parsed];
    }
  }
}

async function getInstalledNpmLibDefs(flowProjectRootDir, libdefDir) {
  const typedefDir = libdefDir || 'flow-typed';

  const libDefDirPath = _node.path.join(flowProjectRootDir, typedefDir, 'npm');

  if (!(await _node.fs.exists(libDefDirPath))) return new Map();
  const filesInNpmDir = await (0, _fileUtils.getFilesInDir)(libDefDirPath, true);
  return new Map((await P.all([...filesInNpmDir].map(fileName => getInstalledNpmLibDef(flowProjectRootDir, _node.path.join(libDefDirPath, fileName))))).filter(Boolean));
}
/**
 * Retrieve single libdef.
 */


async function getSingleLibdef(itemName, npmDefsDirPath, validating) {
  const itemPath = _node.path.join(npmDefsDirPath, itemName);

  const itemStat = await _node.fs.stat(itemPath);

  if (itemStat.isDirectory()) {
    if (itemName[0] === '@') {
      // This must be a scoped npm package, so go one directory deeper
      const scope = itemName;
      const scopeDirItems = await _node.fs.readdir(itemPath);
      const settled = await P.all(scopeDirItems.map(async itemName => {
        const itemPath = _node.path.join(npmDefsDirPath, scope, itemName);

        const itemStat = await _node.fs.stat(itemPath);

        if (itemStat.isDirectory()) {
          return await extractLibDefsFromNpmPkgDir(itemPath, scope, itemName, validating);
        } else {
          throw new _ValidationError.ValidationError(`Expected only sub-directories in this dir!`);
        }
      }));
      return [].concat(...settled);
    } else {
      // itemPath must be a package dir
      return await extractLibDefsFromNpmPkgDir(itemPath, null, // No scope
      itemName, validating);
    }
  } else {
    throw new _ValidationError.ValidationError(`Expected only directories to be present in this directory.`);
  }
}
/**
 * Retrieve a list of *all* npm libdefs.
 */


async function getNpmLibDefs(defsDirPath, validating) {
  const npmDefsDirPath = _node.path.join(defsDirPath, 'npm');

  const dirItems = await _node.fs.readdir(npmDefsDirPath);
  const errors = [];
  const proms = dirItems.map(async itemName => {
    try {
      return await getSingleLibdef(itemName, npmDefsDirPath, validating);
    } catch (e) {
      errors.push(e);
    }
  });
  const settled = await P.all(proms);

  if (errors.length) {
    throw errors;
  }

  return [].concat(...settled).filter(Boolean);
}

async function getNpmLibDefVersionHash(repoDirPath, libDef) {
  const latestCommitHash = await (0, _git.findLatestFileCommitHash)(repoDirPath, _node.path.relative(repoDirPath, libDef.path));
  return `${latestCommitHash.substr(0, 10)}/` + (libDef.scope === null ? '' : `${libDef.scope}/`) + `${libDef.name}_${libDef.version}/` + `flow_${(0, _flowVersion.toSemverString)(libDef.flowVersion)}`;
}

function getScopedPackageName(libDef) {
  return (libDef.scope === null ? '' : `${libDef.scope}/`) + `${libDef.name}`;
}